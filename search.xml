<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络--网络五层结构功能理解</title>
      <link href="2020/10/22/jiwang02/"/>
      <url>2020/10/22/jiwang02/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络–网络五层结构功能理解"><a href="#计算机网络–网络五层结构功能理解" class="headerlink" title="计算机网络–网络五层结构功能理解"></a>计算机网络–网络五层结构功能理解</h1><h4 id="5层网络结构"><a href="#5层网络结构" class="headerlink" title="5层网络结构"></a>5层网络结构</h4><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="大致介绍一下各层级的主要作用和任务"><a href="#大致介绍一下各层级的主要作用和任务" class="headerlink" title="大致介绍一下各层级的主要作用和任务"></a>大致介绍一下各层级的主要作用和任务</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​     在物理层上传输的数据单位是比特。所以物理层的一个主要功能就是<strong>考虑使用多大的电压表示“1”或“0”，以及接收方如何识别发送方所发送的比特</strong>；另外一个任务就是<strong>确定连接电缆的插头应当有多少根引脚，以及各引脚应该如何连接</strong></p><p>​    综合来讲，<strong>物理层的主要任务就是考虑怎样才能在连接各种计算机的传输媒体上传输数据比特流</strong>。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>​    大概念课本上基本都有描述，这里说一下主要的。</p><p>​    数据链路层的主要任务就是<strong>在同一个局域网中，分组怎样从一个主机传送到另外一个主机</strong>（不经过路由）（ps：这里的 分组 在前面的 <a href="https://lovingdrefuse.github.io/2020/09/12/jiwang01/">互联网的核心部分</a> 有详细讲解）<strong>将网络层交下来的IP数据报组装成帧，在相邻节点之间的链路上面传送帧</strong></p><p>帧内包括的数据有：同步信息、地址信息、以及差错控制<br>在几首数据时，控制信息使接收端能够知道一个帧是从哪个比特开始到哪个比特结束。这样数据链路层在接收到一个帧之后就可以从中提取出数据部分，上交给网络层。</p><p>其中，数据链路层的主要工作有三点：</p><ol><li><p>封装成帧：给数据的前后添加商首部和尾部</p></li><li><p>透明传输：某一个实际存在的事物看起来好像确实不存在的一个方法（字节填充法）<br>这么说可能有的人不是很清楚这个到底是啥意思，其实所谓的透明传输就是<strong>不管所传输的数据是什么样的比特组合，都应当能在链路上面传送</strong>，但是如果我们所传输的数据中，恰好某一个比特组合与某一个控制信息一样，这样肯定乱套了啊，所以我们需要采取上面提到的<strong>字节填充法</strong>。</p><p><strong>补充：字节填充法：</strong></p><p>​    <strong>原理</strong>：发送端的数据链路层在数据中出现了控制字符”SOH“或”EOT“的前面加上一个转义字符”ESC“</p><p>简单来说，发送端给特殊的比特组合前添加转义字符，接收端的数据链路层收到数据后把转义字符删除掉，再发给自己的网络层。这样相当于我们在数据链路层中实现了一个方法，但是在别的层级中好像啥也没干—–这就是透明传输</p></li><li><p>差错检测：控制信息还能够检测所收到的帧中有无差错，如果有差错就丢弃这个出错的帧，避免后面浪费资源（ps：如果需要改正这些出错的帧，就需要采用可靠传输协议RTP，这种方法会使数据链路层的协议复杂一些）。</p></li></ol><h4 id="网络层（IP层）"><a href="#网络层（IP层）" class="headerlink" title="网络层（IP层）"></a>网络层（IP层）</h4><p>​    主要任务：</p><ol><li>分组怎样从一个网络通过路由器转发到另一个网络</li><li>为交换网上的不同主机提供通信服务</li><li>把传输层产生的报文段或用户数据报封装成分组或包进行传送(IP数据报)</li><li>选择合适的路由，使源主机运输层传下来的分组能够通过网络中的路由器找到目的主机</li></ol><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>​    主要任务：向两个住进中进程之间的通信提供通用的数据传输服务</p><p>​    这里涉及到两个协议（TCP/UDP）：</p><p>​    TCP：面向连接的、可靠的数据传输服务，传输的数据单位是报文段</p><p>​    UDP：无连接的、尽最大努力的数据传输服务(不可靠的)，数据传输单位是用户数据报</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​    主要任务：位于不同主机中的多个应用进程之间进行通信和协同工作</p><p>​    涉及到DNS域名解析</p><h4 id="每一个的层级任务已经讲解完了，现在来看一下一条数据是怎么进行传递的："><a href="#每一个的层级任务已经讲解完了，现在来看一下一条数据是怎么进行传递的：" class="headerlink" title="每一个的层级任务已经讲解完了，现在来看一下一条数据是怎么进行传递的："></a>每一个的层级任务已经讲解完了，现在来看一下一条数据是怎么进行传递的：</h4><p>1、某进程(也就是在应用层)准备好待传输数据，若目的地址是域名则要先通过DNS解析成IP地址</p><p>2、交付到运输层(TCP/UDP层)，运输层对数据进行适当的分组等操作，后对每一个分组数组加上首部形成报文段(或用户数据报)首部包括源地址、源端口、目的地址、目的端口和一些其他的诸如校验和等数据</p><p>3、交付到网际层(IP层)，对分组数据加上首部形成IP数据报，首部包括源地址、目的地址(跟运输层的目的地址不同，运输层的目的地址是数据要传送的最终地址，而该目的地址是通过路由表信息得出，是该数据下一步该转移的目的计算机)和校验和等数据</p><p>4、交付到数据链路层(mac层)，先是对把数据封装成帧(也就是添加首部[SOH]和尾部[EOT])，然后进行透明传输(也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节/字符填充)</p><p>5、交付到物理层，根据数据链路层的mac知道要传输到目的计算机，通过特定的传输介质传送到下一个地址</p><p>6、若源主机与最终目的主机在同一个网段，则该地址是最终的目的主机，开始接收数据，进入第7步骤，若源主机和最终目的主机不在同一个网段，进入第11步骤</p><p>7、交付到数据链路层，对数据进行卸装，该层会对接收的数据进行差错检测，有差错的数据都会被丢弃</p><p>8、交付到IP层，解帧校验</p><p>9、交付到运输层，在该主机上，根据端口找到对应的应用，当使用的TCP协议时，提供一种面向连接的可靠的传输服务，可以说是建立了一个虚拟通道，源主机的数据通过该虚拟通道进行传输；若是使用的UDP协议时，提供一种面向的非连接的尽最大努力的不可靠的传输服务，数据传输快，但是无法保证数据100%传输。</p><p>10、建立了传输连接后，应用开始接收数据，发送方数据和接收方都必须满足相同的标准应用层协议，如http、ftp、smtp等，通过标准协议应用即可正确的接收源主机发送过来的数据。</p><p>11、该计算机不是最终主机，那该计算机就是路由器也就是用于转发分组数据的中转站，首先接收数据的处理同步骤7和8一样，然后接下来的流程又是如同步骤3,</p><p>12、如此循环直至找到最终主机，将数据传送到目的应用</p><p>数据封装过程的图解如下：</p><p><img src="https://img-blog.csdn.net/20180808192707663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTYzNzEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数据封装过程"></p><p>其实到这里基本上我们对各层级之间的数据处理关系已经了解了，下面有一个特别贴切的例子（俺逛csdn时候看到的，来源戳这里👉<a href="https://blog.csdn.net/qq_32563713/article/details/81514061">https://blog.csdn.net/qq_32563713/article/details/81514061</a>）：</p><h4 id="案例：从西班牙去罗马的贸易商人"><a href="#案例：从西班牙去罗马的贸易商人" class="headerlink" title="案例：从西班牙去罗马的贸易商人"></a>案例：从西班牙去罗马的贸易商人</h4><p>1、 要想贸易获得成功，首先要有至少一条路，能够从西班牙通向罗马。此层为【物理层】</p><p>2、有了路是不是就能去贸易了？还要保证路上不会把商人的货物给磕坏了，要有一层保护的包装。引出第二层，【数据链路层】</p><p>3、所谓条条道路通罗马。并不只有一条路能够到达罗马，那么在那么多的选择中选一条最短的，或者路费的成本最少的，这才符合商人的利益。引出第三层，【网络层】</p><p>以上三层为网络中的下三层，叫媒体层，让我们来看看另外4层。</p><p>4、贸易出门前要先检查一下自己的货，有没有拿错了，事先要检查过，如果错了要重新取货，引出第四层，【传输层】。</p><p>5、是不是可以上路了？还不行。我们要和罗马联系好， 如果我们这边的货物到了那边卖不出去怎么办？我们首先要交流、协商一下，看看罗马的市场情况，能和那边的另外一个商人合作的话就更好了，这就需要一些外交的关系。叫做【会话层】。</p><p>6、好象所有的事情都准备好了，但是商人到了罗马以后突然发现，他的商队里没有人能听懂罗马人的话，罗马人也没有人能听懂西班牙语，这个时候，还需要一个翻译，要么把两种语言都转换成一种国际通用语言，比如说英语，要么至少能让双方能交流。这里就是【表示层】。</p><p>7、到了罗马了，最终需要在交易所中把商品卖掉，这个交易所就是一个交易平台,相当于各个软件平台，引出最后一层，【应用层】。</p><p>其实，从应用层到物理层，再从物理层到应用层，都是一个包洋葱和剥洋葱的过程，中间的每一片洋葱都是一个层级的任务，这样想是不是好理解多了🙂</p><p>网络层级之间的关系到这里已经说完啦，有什么地方不对，望斧正，觉得俺写的还勉强可以的，希望能星星一下，谢啦。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>互联网核心部分</title>
      <link href="2020/09/12/jiwang01/"/>
      <url>2020/09/12/jiwang01/</url>
      
        <content type="html"><![CDATA[<h1 id="互联网核心部分"><a href="#互联网核心部分" class="headerlink" title="互联网核心部分"></a>互联网核心部分</h1><h4 id="互联网分为两个部分："><a href="#互联网分为两个部分：" class="headerlink" title="互联网分为两个部分："></a>互联网分为两个部分：</h4><p>（1）<strong>边缘部分</strong>：由所有连接在互联网上的主机构成，用户直接使用。<br>（2）<strong>核心部分</strong>：由大量的网络和连接这些网络的路由器组成，为边缘部分提供服务。<br>其中最重要和最复杂的就是核心部分。</p><hr><p>在网络核心部分起特殊作用的是路由器，是一种专用的计算机，是实现<strong>分组交换</strong>的关键构件。在介绍分组交换之前，先介绍电路交换的基本概率。</p><p>先对三种交换方式进行简单介绍：</p><p>电路交换——整个报文的比特流连续地从源点直到终点，好像在一个管道中传送。<br>报文交换——整个报文先传送到相邻的结点，全部存储下来后查找转发表，转发到下一个结点。<br>分组交换——单个分组（这只是整个报文中的一部分）传送到相邻的结点，存储下来后查找转发表，转发到下一个结点。</p><p>下面是详细介绍：</p><p><strong>1、电路交换</strong><br>实现两两连接是不可能的，所以出现了交换机。“交换”就是转接，把一条电话线转接到另一条电话线，使它们连接起来。电路交换机必定是面向连接的：物理连接+逻辑连接。没有物理连接，就没有逻辑连接。逻辑连接先结束，物理连接后结束。过程：建立连接–&gt;通话–&gt;释放连接。电路交换的一个重要特点就是<strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</p><p>先看看电路交换、报文交换、分组交换的图解：</p><p><img src="/jiaohuan.png"></p><p>​    从图中可以看到：</p><p>​        在电路交换中：</p><p>​        开始的三段路线是链接建立的过程，本机与目标地址中间有着多条链路，所以有多段链接建立时间</p><p>​        第二段线路即目标地址收到链接建立信号，返回成功信号给本机</p><p>​        第三段即数据传送过程</p><p>但是电路交换的优缺点也能够明显的从图中看出来：</p><p>优点：在数据的传输上是比较<strong>高效、实时的</strong>，当发送方一发出数据，接收方立马就能够收到。</p><p>缺点：<strong>资源利用率低，建立连接时间太长。</strong></p><p>在电路交换中，接收方和发送方之间只有一条单一线路，就单单二者就占据了这一整条线路，这时如果有别的节点需要对接收方进行数据传输就需要等待，所以电路交换这种方式对互联网上的资源有着极大的浪费，从另一个方面来说的话，如果我只需要发送一个简短的消息，那我建立电路所花费的时间可能比我使用这条线路的时间还要长，这就得不偿失了。</p><p><strong>2、报文交换</strong></p><p>​        每一个结点接收整个报文，检查目标结点地址，然后根据网络中的交通情况在适当的时候转发到下一个结点。经过多次的存储——转发，最后到达目标，因而这样的网络叫存储——转发网络。其中的交换结点要有足够大的储存空间（一般是磁盘），用以缓冲收到的长报文。</p><p>交换结点对各个方向上收到的报文排队，对照下一个转结点，然后再转发出去，这些都带来了排队等待延迟。报文交换的优点是不建立专用链路，但是线路利用率较高，这是由通信中的等待时延换来的。</p><p>所以报文交换相对于电路交换的优缺点也很明显：</p><p>优点</p><p>①报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。</p><p>②由于采用存储转发的传输方式，使之具有下列优点：a.在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性；b.在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信；c.提供多目标服务，即一个报文可以同时发送到多个目的地址，这在电路交换中是很难实现的；d.允许建立数据传输的优先级，使优先级高的报文优先转换。</p><p>③通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。</p><p>缺点</p><p>①由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。</p><p>②报文交换只适用于数字信号。</p><p>③由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p><p>**3、分组交换 **<br>分组交换采用存储转发的技术。通常将要发送的整块数据称为一个报文，把报文划分为几个分组后再进行传送。在每个数据段前面，加上一些由必要的控制信息组成的首部后，就构成了一个分组。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的借口转发出去，把分组交给下一个路由器。</p><p>​    相对于电路交换，分组交换所分成的每一个分组都可以从不同的路线到达目的地址，并且每一个分组的数据大小相对于电路交换也小很多，所以传输的速度会快很多，更重要的是，分组交换并不需要像电路交换那样进行路线试探。</p><p>所以看起来分组交换绝对优于电路交换？ 当然不对</p><p>分组交换也有其优缺点的：</p><p>优点：</p><p> ①加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。  </p><p> ②简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。</p><p> ③减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。  </p><p>④由于分组短小，更适用于采用优先级策略，便于及时传送一些紧急数据，因此对于计算机之间的突发式的数据通信，分组交换显然更为合适些。</p><p> 缺点：</p><p>①尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。  </p><p>②分组交换与报文交换一样，每个分组都要加上源、目的地址和分组编号等信息，使传送的信息量大约增大5%～10%，一定程度上降低了通信效率，<strong>增加了处理的时间，使控制复杂，时延增加</strong>。  </p><p>③当分组交换采用<strong>数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。</strong>若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。  </p><p>总之，若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/12/hello-world/"/>
      <url>2020/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
